import asyncio
import re
from typing import Optional, List
import websockets
from httpx import AsyncClient, Cookies


class ShellCommand:
    _cmd: str
    ok: str
    err: str

    def __init__(self, _cmd: str, ok: str, err: str) -> None:
        self.cmd = _cmd
        self.ok = ok
        self.err = err

    @property
    def cmd(self) -> str:
        return self._cmd + "\n"

    @cmd.setter
    def cmd(self, _cmd):
        self._cmd = _cmd


class ShellCommandErrorBuilder:
    cmd: str
    ok: str

    def __init__(self, cmd: str, ok: str) -> None:
        self.cmd = cmd
        self.ok = ok

    def err(self) -> ShellCommand:
        return ShellCommand(self.cmd + ' || echo "\\nERROR"', self.ok, ".*\nERROR.*")

    def errext(self) -> ShellCommand:
        return ShellCommand(
            self.cmd + ' && echo "\\nERROR" || echo "\\nERROR"', self.ok, ".*\nERROR.*"
        )

    def fail(self, err: str, suffix="") -> ShellCommand:
        return ShellCommand(self.cmd + suffix, self.ok, err)

    def default(self) -> ShellCommand:
        return self.err()


class ShellCommandBuilder:
    cmd: str

    def __init__(self, cmd: str) -> None:
        self.cmd = cmd

    def ok(self) -> ShellCommandErrorBuilder:
        return ShellCommandErrorBuilder(self.cmd + ' && echo "\\nOK"', ".*\nOK.*")

    def expect(self, ok: str, suffix="") -> ShellCommandErrorBuilder:
        return ShellCommandErrorBuilder(self.cmd + suffix, ok)

    def default(self) -> ShellCommand:
        return self.ok().err()


def sh(cmd: str):
    return ShellCommandBuilder(cmd)


class ShellCommandChain:
    command_chain: List[ShellCommand]
    validation_chain: List[ShellCommand]

    def __init__(
        self, cmds: List[ShellCommand], validations: List[ShellCommand]
    ) -> None:
        self.command_chain = cmds
        self.validation_chain = validations


def shchain(cmds: List[ShellCommand] = [], validations: List[ShellCommand] = []):
    return ShellCommandChain(cmds, validations)


async def do_repl_auth(
    client: AsyncClient, username: str, password: str
) -> tuple[Cookies, str]:
    response = await client.post(
        "/api/repl",
        data={"username": username, "password": password},
        follow_redirects=True,
    )

    if response.status_code >= 300:
        raise Exception("Creating repl user failed")

    json = response.json()
    id = json["id"]
    if id is None:
        raise Exception("Did not receive a repl id")

    cookies = response.cookies

    return (cookies, id)


async def do_user_register(
    client: AsyncClient,
    username: str,
    password: str,
):
    response = await client.post(
        "/api/auth/register",
        data={"username": username, "password": password},
        follow_redirects=True,
    )

    if response.status_code >= 300:
        raise Exception("Creating user failed")


async def do_user_login(
    client: AsyncClient,
    username: str,
    password: str,
) -> Cookies:
    response = await client.post(
        "/api/auth/login",
        data={"username": username, "password": password},
        follow_redirects=True,
    )

    if response.status_code >= 300:
        raise Exception("Login failed")

    cookies = response.cookies

    return cookies


async def do_create_devenv(
    client: AsyncClient,
    cookies: Cookies,
    name: str,
    buildCmd: str,
    runCmd: str,
) -> str:
    response = await client.post(
        "/api/devenv",
        json={
            "name": name,
            "buildCmd": buildCmd,
            "runCmd": runCmd,
        },
        follow_redirects=True,
        headers={"Cookie": "session=" + (cookies.get("session") or "")},
    )
    if response.status_code >= 300:
        raise Exception("Creating devenv failed")

    json = response.json()
    devenvUuid = json["devenvUuid"]
    if devenvUuid is None:
        raise Exception("Did not receive a devenvUuid")

    return devenvUuid


async def do_get_devenv_file_content(
    client: AsyncClient,
    cookies: Cookies,
    devenvUuid: str,
    filename: str,
    query: str = "",
) -> str:
    response = await client.get(
        "/api/devenv/" + devenvUuid + "/files/" + filename + query,
        follow_redirects=True,
        headers={
            "Cookie": "session=" + (cookies.get("session") or ""),
        },
    )
    if response.status_code >= 300:
        raise Exception("Getting file content failed")
    return response.text


async def websocket_recv_until(
    websocket: websockets.WebSocketClientProtocol,
    expected: str,
    unexpected: Optional[str],
) -> str:
    payload = ""
    match = None

    while match is None:
        msg = await asyncio.wait_for(websocket.recv(), timeout=10)
        if isinstance(msg, bytes):
            payload += msg.decode("utf-8")
        elif isinstance(msg, str):
            payload += msg
        else:
            raise Exception("Websocket connection recv returned unexpected data")
        match = re.match(expected, payload, re.S)
        if (
            match is None
            and unexpected is not None
            and re.match(unexpected, payload, re.S) is not None
        ):
            raise Exception("Received unexpected input")

    return payload


async def repl_websocket(
    address: str,
    cookies: Cookies,
    id: str,
    actions: List[ShellCommand],
):
    url = f"ws://{address}:6969/api/repl/{id}"
    response = ""
    cookie = cookies.get("session")
    async with websockets.connect(
        url, extra_headers={"Cookie": f"session={cookie}"}
    ) as websocket:
        await websocket_recv_until(websocket, ".*%.*", None)
        for action in actions:
            await websocket.send(action.cmd)
            _response = await websocket_recv_until(websocket, action.ok, action.err)
            response += _response

    return response
